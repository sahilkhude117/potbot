import { Connection, Keypair, PublicKey, SystemProgram, TransactionInstruction, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { decodeSecretKey } from "../lib/utils";

const PROGRAM_ID = new PublicKey("636NmFV9Nhr2TV49RyjJUp2kyBVbnZFMmPqQjvHeJNzU");
const RPC_URL = process.env.RPC_URL || "https://api.devnet.solana.com";


export function getPotPDA(adminPublicKey: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("pot"), adminPublicKey.toBuffer()],
    PROGRAM_ID
  );
}


function getConnection(): Connection {
  return new Connection(RPC_URL, "confirmed");
}

// Instruction discriminators (first 8 bytes of instruction data)
// These are generated by Anchor from the instruction name
const INSTRUCTION_DISCRIMINATORS = {
  initializePot: Buffer.from([169, 131, 191, 237, 122, 135, 203, 67]), // sha256("global:initialize_pot")[0..8]
  addTrader: Buffer.from([31, 161, 110, 235, 39, 57, 68, 229]),       // sha256("global:add_trader")[0..8]
  removeTrader: Buffer.from([123, 134, 200, 251, 206, 117, 61, 216]), // sha256("global:remove_trader")[0..8]
};


function serializeFees(performanceFeeBps: number, redemptionFeeBps: number): Buffer {
  const data = Buffer.alloc(4);
  data.writeUInt16LE(performanceFeeBps, 0);
  data.writeUInt16LE(redemptionFeeBps, 2);
  return data;
}

export async function initializePotOnChain(
  adminPrivateKey: string,
  performanceFeeBps: number = 0,
  redemptionFeeBps: number = 0
): Promise<{ signature: string; potPDA: PublicKey }> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);

    // Create instruction data: discriminator + fees
    const feesData = serializeFees(performanceFeeBps, redemptionFeeBps);
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.initializePot,
      feesData
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Pot initialized on-chain. Signature: ${signature}`);
    console.log(`✅ Pot PDA: ${potPda.toBase58()}`);

    return { signature, potPDA: potPda };
  } catch (error) {
    console.error("❌ Error initializing pot on-chain:", error);
    throw new Error(`Failed to initialize pot on-chain: ${error}`);
  }
}

export async function addTraderOnChain(
  adminPrivateKey: string,
  traderPublicKey: string
): Promise<string> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);
    const traderPubkey = new PublicKey(traderPublicKey);

    // Create instruction data: discriminator + trader pubkey (32 bytes)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.addTrader,
      traderPubkey.toBuffer()
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Trader added on-chain. Signature: ${signature}`);
    console.log(`✅ Trader: ${traderPublicKey}`);

    return signature;
  } catch (error) {
    console.error("❌ Error adding trader on-chain:", error);
    throw new Error(`Failed to add trader on-chain: ${error}`);
  }
}

export async function removeTraderOnChain(
  adminPrivateKey: string,
  traderPublicKey: string
): Promise<string> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);
    const traderPubkey = new PublicKey(traderPublicKey);

    // Create instruction data: discriminator + trader pubkey (32 bytes)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.removeTrader,
      traderPubkey.toBuffer()
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Trader removed on-chain. Signature: ${signature}`);
    console.log(`✅ Trader: ${traderPublicKey}`);

    return signature;
  } catch (error) {
    console.error("❌ Error removing trader on-chain:", error);
    throw new Error(`Failed to remove trader on-chain: ${error}`);
  }
}

export async function getPotAccountData(adminPublicKey: string): Promise<any> {
  try {
    const connection = getConnection();
    const adminPubkey = new PublicKey(adminPublicKey);
    const [potPda] = getPotPDA(adminPubkey);

    const accountInfo = await connection.getAccountInfo(potPda);
    
    if (!accountInfo) {
      throw new Error("Pot account not found");
    }

    // Basic deserialization - adjust based on your Pot struct layout
    // This is a simplified version - you may need to adjust based on actual account structure
    const data = accountInfo.data;
    
    console.log(`✅ Pot account data fetched for PDA: ${potPda.toBase58()}`);
    
    return {
      pda: potPda.toBase58(),
      owner: accountInfo.owner.toBase58(),
      dataLength: data.length,
      // Add more deserialization as needed
    };
  } catch (error) {
    console.error("❌ Error fetching pot account data:", error);
    throw new Error(`Failed to fetch pot account data: ${error}`);
  }
}
