import { 
  Connection, 
  Keypair, 
  PublicKey, 
  SystemProgram, 
  TransactionInstruction, 
  Transaction, 
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL 
} from "@solana/web3.js";
import { 
  getAssociatedTokenAddress, 
  TOKEN_PROGRAM_ID,
  createAssociatedTokenAccountInstruction,
  getAccount,
  createSyncNativeInstruction,
  NATIVE_MINT
} from "@solana/spl-token";
import { decodeSecretKey } from "../lib/utils";
import { SOL_MINT } from "../lib/statits";

const PROGRAM_ID = new PublicKey("636NmFV9Nhr2TV49RyjJUp2kyBVbnZFMmPqQjvHeJNzU");
const RPC_URL = process.env.RPC_URL || "https://api.devnet.solana.com";
const WRAPPED_SOL_MINT = new PublicKey(SOL_MINT);

/**
 * Derives the Pot PDA address
 * Seeds: ["pot", adminPublicKey]
 */
export function getPotPDA(adminPublicKey: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("pot"), adminPublicKey.toBuffer()],
    PROGRAM_ID
  );
}

/**
 * Derives the MemberData PDA address
 * Seeds: ["member", potPDA, userPublicKey]
 */
export function getMemberDataPDA(potPDA: PublicKey, userPublicKey: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("member"), potPDA.toBuffer(), userPublicKey.toBuffer()],
    PROGRAM_ID
  );
}


function getConnection(): Connection {
  return new Connection(RPC_URL, "confirmed");
}

// Instruction discriminators (first 8 bytes of instruction data)
// These are generated by Anchor from SHA256("global:instruction_name")
const INSTRUCTION_DISCRIMINATORS = {
  initializePot: Buffer.from([142, 71, 252, 186, 244, 59, 203, 118]), // initialize_pot
  addTrader: Buffer.from([242, 5, 40, 133, 11, 55, 94, 217]),         // add_trader
  removeTrader: Buffer.from([60, 148, 215, 48, 228, 172, 5, 194]),    // remove_trader
  deposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]),       // deposit (was already correct!)
  redeem: Buffer.from([184, 12, 86, 149, 70, 196, 97, 225]),          // redeem (was already correct!)
};

/**
 * Serializes PotFees struct
 */
function serializeFees(performanceFeeBps: number, redemptionFeeBps: number): Buffer {
  const data = Buffer.alloc(4);
  data.writeUInt16LE(performanceFeeBps, 0);
  data.writeUInt16LE(redemptionFeeBps, 2);
  return data;
}

/**
 * Serializes u64 value (8 bytes, little-endian)
 */
function serializeU64(value: bigint): Buffer {
  const buffer = Buffer.alloc(8);
  buffer.writeBigUInt64LE(value);
  return buffer;
}

/**
 * Serializes PublicKey (32 bytes)
 */
function serializePublicKey(pubkey: PublicKey): Buffer {
  return pubkey.toBuffer();
}

/**
 * Initializes a pot on-chain with fees and base mint
 * @param adminPrivateKey - Admin's private key
 * @param performanceFeeBps - Performance fee in basis points (default: 0)
 * @param redemptionFeeBps - Redemption fee in basis points (default: 0)
 * @param baseMint - Base mint address (default: Wrapped SOL)
 */
export async function initializePotOnChain(
  adminPrivateKey: string,
  performanceFeeBps: number = 0,
  redemptionFeeBps: number = 0,
  baseMint: PublicKey = WRAPPED_SOL_MINT
): Promise<{ signature: string; potPDA: PublicKey }> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);

    // Create instruction data: discriminator + fees + baseMint
    const feesData = serializeFees(performanceFeeBps, redemptionFeeBps);
    const baseMintData = serializePublicKey(baseMint);
    
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.initializePot,
      feesData,
      baseMintData
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Pot initialized on-chain. Signature: ${signature}`);
    console.log(`✅ Pot PDA: ${potPda.toBase58()}`);

    return { signature, potPDA: potPda };
  } catch (error) {
    console.error("❌ Error initializing pot on-chain:", error);
    throw new Error(`Failed to initialize pot on-chain: ${error}`);
  }
}

export async function addTraderOnChain(
  adminPrivateKey: string,
  traderPublicKey: string
): Promise<string> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);
    const traderPubkey = new PublicKey(traderPublicKey);

    // Create instruction data: discriminator + trader pubkey (32 bytes)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.addTrader,
      traderPubkey.toBuffer()
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Trader added on-chain. Signature: ${signature}`);
    console.log(`✅ Trader: ${traderPublicKey}`);

    return signature;
  } catch (error) {
    console.error("❌ Error adding trader on-chain:", error);
    throw new Error(`Failed to add trader on-chain: ${error}`);
  }
}

export async function removeTraderOnChain(
  adminPrivateKey: string,
  traderPublicKey: string
): Promise<string> {
  try {
    const secretKey = decodeSecretKey(adminPrivateKey);
    const adminKeypair = Keypair.fromSecretKey(secretKey);
    
    const connection = getConnection();
    const [potPda] = getPotPDA(adminKeypair.publicKey);
    const traderPubkey = new PublicKey(traderPublicKey);

    // Create instruction data: discriminator + trader pubkey (32 bytes)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.removeTrader,
      traderPubkey.toBuffer()
    ]);

    // Create the instruction
    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminKeypair.publicKey, isSigner: true, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [adminKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Trader removed on-chain. Signature: ${signature}`);
    console.log(`✅ Trader: ${traderPublicKey}`);

    return signature;
  } catch (error) {
    console.error("❌ Error removing trader on-chain:", error);
    throw new Error(`Failed to remove trader on-chain: ${error}`);
  }
}

export async function getPotAccountData(adminPublicKey: string): Promise<any> {
  try {
    const connection = getConnection();
    const adminPubkey = new PublicKey(adminPublicKey);
    const [potPda] = getPotPDA(adminPubkey);

    const accountInfo = await connection.getAccountInfo(potPda);
    
    if (!accountInfo) {
      throw new Error("Pot account not found");
    }

    // Basic deserialization - adjust based on your Pot struct layout
    // This is a simplified version - you may need to adjust based on actual account structure
    const data = accountInfo.data;
    
    console.log(`✅ Pot account data fetched for PDA: ${potPda.toBase58()}`);
    
    return {
      pda: potPda.toBase58(),
      owner: accountInfo.owner.toBase58(),
      dataLength: data.length,
      // Add more deserialization as needed
    };
  } catch (error) {
    console.error("❌ Error fetching pot account data:", error);
    throw new Error(`Failed to fetch pot account data: ${error}`);
  }
}

/**
 * Deposits tokens into a pot using the smart contract
 * @param userPrivateKey - User's private key
 * @param adminPublicKey - Pot admin's public key (for PDA derivation)
 * @param amount - Amount to deposit in SOL (will be converted to lamports)
 * @param baseMint - Base mint address (default: Wrapped SOL)
 */
export async function depositToPot(
  userPrivateKey: string,
  adminPublicKey: string,
  amount: number,
  baseMint: PublicKey = WRAPPED_SOL_MINT
): Promise<{ signature: string; sharesMinted: bigint }> {
  try {
    const secretKey = decodeSecretKey(userPrivateKey);
    const userKeypair = Keypair.fromSecretKey(secretKey);
    const userPublicKey = userKeypair.publicKey;
    
    const connection = getConnection();
    const adminPubkey = new PublicKey(adminPublicKey);
    
    // Derive PDAs
    const [potPda] = getPotPDA(adminPubkey);
    const [memberDataPda] = getMemberDataPDA(potPda, userPublicKey);
    
    // Get or create ATAs
    const potVaultAta = await getAssociatedTokenAddress(
      baseMint,
      potPda,
      true // Allow PDA owner
    );
    
    const userVaultAta = await getAssociatedTokenAddress(
      baseMint,
      userPublicKey
    );

    // Convert amount to lamports (u64)
    const depositAmountLamports = BigInt(Math.floor(amount * LAMPORTS_PER_SOL));
    
    // Create instruction data: discriminator + amount (u64)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.deposit,
      serializeU64(depositAmountLamports)
    ]);

    const instructions: TransactionInstruction[] = [];

    // Check if this is wrapped SOL (native mint)
    const isWrappedSol = baseMint.equals(NATIVE_MINT);

    // Check if user's ATA exists, create if not
    let userAtaExists = false;
    try {
      await getAccount(connection, userVaultAta);
      userAtaExists = true;
    } catch (e) {
      instructions.push(
        createAssociatedTokenAccountInstruction(
          userPublicKey,
          userVaultAta,
          userPublicKey,
          baseMint
        )
      );
    }

    // For wrapped SOL, we need to transfer SOL to the ATA and sync
    if (isWrappedSol) {
      // Transfer SOL to the wrapped SOL account
      instructions.push(
        SystemProgram.transfer({
          fromPubkey: userPublicKey,
          toPubkey: userVaultAta,
          lamports: depositAmountLamports,
        })
      );
      
      // Sync native to update the token balance
      instructions.push(
        createSyncNativeInstruction(userVaultAta)
      );
    }

    // Check if pot's ATA exists, create if not
    try {
      await getAccount(connection, potVaultAta);
    } catch (e) {
      instructions.push(
        createAssociatedTokenAccountInstruction(
          userPublicKey, // Payer
          potVaultAta,
          potPda,
          baseMint
        )
      );
    }

    // Create the deposit instruction
    const depositInstruction = new TransactionInstruction({
      keys: [
        { pubkey: userPublicKey, isSigner: true, isWritable: true },
        { pubkey: memberDataPda, isSigner: false, isWritable: true },
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: baseMint, isSigner: false, isWritable: false },
        { pubkey: potVaultAta, isSigner: false, isWritable: true },
        { pubkey: userVaultAta, isSigner: false, isWritable: true },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    instructions.push(depositInstruction);

    // Create and send transaction
    const transaction = new Transaction().add(...instructions);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [userKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Deposit successful! Signature: ${signature}`);
    console.log(`✅ Amount: ${amount} SOL`);

    // Note: To get sharesMinted, you'd need to parse transaction logs or account data
    // For now, returning 0 as placeholder
    return { signature, sharesMinted: BigInt(0) };
  } catch (error) {
    console.error("❌ Error depositing to pot:", error);
    throw new Error(`Failed to deposit to pot: ${error}`);
  }
}

/**
 * Redeems (withdraws) tokens from a pot using the smart contract
 * @param userPrivateKey - User's private key
 * @param adminPublicKey - Pot admin's public key (for PDA derivation)
 * @param sharesToBurn - Number of shares to burn
 * @param baseMint - Base mint address (default: Wrapped SOL)
 */
export async function redeemFromPot(
  userPrivateKey: string,
  adminPublicKey: string,
  sharesToBurn: bigint,
  baseMint: PublicKey = WRAPPED_SOL_MINT
): Promise<{ signature: string; amountReceived: bigint }> {
  try {
    const secretKey = decodeSecretKey(userPrivateKey);
    const userKeypair = Keypair.fromSecretKey(secretKey);
    const userPublicKey = userKeypair.publicKey;
    
    const connection = getConnection();
    const adminPubkey = new PublicKey(adminPublicKey);
    
    // Derive PDAs
    const [potPda] = getPotPDA(adminPubkey);
    const [memberDataPda] = getMemberDataPDA(potPda, userPublicKey);
    
    // Get ATAs
    const potVaultAta = await getAssociatedTokenAddress(
      baseMint,
      potPda,
      true
    );
    
    const userVaultAta = await getAssociatedTokenAddress(
      baseMint,
      userPublicKey
    );

    // Create instruction data: discriminator + sharesToBurn (u64)
    const instructionData = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.redeem,
      serializeU64(sharesToBurn)
    ]);

    const instructions: TransactionInstruction[] = [];

    // Check if user's ATA exists, create if not
    try {
      await getAccount(connection, userVaultAta);
    } catch (e) {
      instructions.push(
        createAssociatedTokenAccountInstruction(
          userPublicKey,
          userVaultAta,
          userPublicKey,
          baseMint
        )
      );
    }

    // Create the redeem instruction
    const redeemInstruction = new TransactionInstruction({
      keys: [
        { pubkey: userPublicKey, isSigner: true, isWritable: true },
        { pubkey: memberDataPda, isSigner: false, isWritable: true },
        { pubkey: potPda, isSigner: false, isWritable: true },
        { pubkey: adminPubkey, isSigner: false, isWritable: false },
        { pubkey: potVaultAta, isSigner: false, isWritable: true },
        { pubkey: userVaultAta, isSigner: false, isWritable: true },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      ],
      programId: PROGRAM_ID,
      data: instructionData,
    });

    instructions.push(redeemInstruction);

    // Create and send transaction
    const transaction = new Transaction().add(...instructions);
    const signature = await sendAndConfirmTransaction(
      connection,
      transaction,
      [userKeypair],
      { commitment: 'confirmed' }
    );

    console.log(`✅ Redemption successful! Signature: ${signature}`);
    console.log(`✅ Shares burned: ${sharesToBurn.toString()}`);

    // Note: To get amountReceived, you'd need to parse transaction logs or account data
    // For now, returning 0 as placeholder
    return { signature, amountReceived: BigInt(0) };
  } catch (error) {
    console.error("❌ Error redeeming from pot:", error);
    throw new Error(`Failed to redeem from pot: ${error}`);
  }
}

